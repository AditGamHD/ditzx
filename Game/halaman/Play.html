<div class="game-play-container">
    <div class="game-header">
        <div class="game-info">
            <h2 id="gameTitle">Loading Game...</h2>
            <div class="game-meta">
                <span id="gameAuthor"></span>
                <span id="gameDifficulty"></span>
                <span id="gameTime"></span>
            </div>
        </div>
        
        <div class="game-stats">
            <div class="stat-item">
                <i class="fas fa-heart"></i>
                <span id="health">100</span>
            </div>
            <div class="stat-item">
                <i class="fas fa-coins"></i>
                <span id="coins">0</span>
            </div>
            <div class="stat-item">
                <i class="fas fa-star"></i>
                <span id="score">0</span>
            </div>
            <div class="stat-item">
                <i class="fas fa-clock"></i>
                <span id="timer">00:00</span>
            </div>
        </div>
        
        <div class="game-controls-top">
            <button class="game-btn" id="pauseBtn">
                <i class="fas fa-pause"></i>
            </button>
            <button class="game-btn" id="restartBtn">
                <i class="fas fa-redo"></i>
            </button>
            <button class="game-btn" id="exitBtn">
                <i class="fas fa-times"></i>
            </button>
        </div>
    </div>
    
    <div class="game-content">
        <div class="game-canvas-container">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            
            <div class="mobile-controls" id="mobileControls">
                <div class="control-stick left" id="leftStick">
                    <div class="stick-inner"></div>
                </div>
                <div class="control-buttons">
                    <button class="control-btn jump" id="mobileJump">
                        <i class="fas fa-arrow-up"></i>
                    </button>
                    <button class="control-btn action" id="mobileAction">
                        <i class="fas fa-bolt"></i>
                    </button>
                </div>
            </div>
            
            <!-- Game Over Screen -->
            <div class="game-overlay" id="pauseScreen" style="display: none;">
                <div class="overlay-content">
                    <h2><i class="fas fa-pause"></i> Game Paused</h2>
                    <div class="overlay-stats">
                        <div>Coins: <span id="pauseCoins">0</span></div>
                        <div>Time: <span id="pauseTime">00:00</span></div>
                        <div>Score: <span id="pauseScore">0</span></div>
                    </div>
                    <div class="overlay-buttons">
                        <button class="overlay-btn" id="resumeBtn">
                            <i class="fas fa-play"></i> Resume
                        </button>
                        <button class="overlay-btn" id="restartOverlayBtn">
                            <i class="fas fa-redo"></i> Restart
                        </button>
                        <button class="overlay-btn" id="exitOverlayBtn">
                            <i class="fas fa-times"></i> Exit
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="game-overlay" id="gameOverScreen" style="display: none;">
                <div class="overlay-content">
                    <h2><i class="fas fa-skull-crossbones"></i> Game Over</h2>
                    <div class="overlay-stats">
                        <div>Coins Collected: <span id="finalCoins">0</span></div>
                        <div>Time Survived: <span id="finalTime">00:00</span></div>
                        <div>Final Score: <span id="finalScore">0</span></div>
                    </div>
                    <div class="overlay-buttons">
                        <button class="overlay-btn" id="retryBtn">
                            <i class="fas fa-redo"></i> Try Again
                        </button>
                        <button class="overlay-btn" id="exitGameOverBtn">
                            <i class="fas fa-times"></i> Exit
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="game-overlay" id="winScreen" style="display: none;">
                <div class="overlay-content">
                    <h2><i class="fas fa-flag-checkered"></i> Level Complete!</h2>
                    <div class="overlay-stats">
                        <div>Total Coins: <span id="winCoins">0</span></div>
                        <div>Completion Time: <span id="winTime">00:00</span></div>
                        <div>Total Score: <span id="winScore">0</span></div>
                    </div>
                    <div class="achievements" id="winAchievements">
                        <!-- Achievements will be added here -->
                    </div>
                    <div class="overlay-buttons">
                        <button class="overlay-btn" id="nextLevelBtn">
                            <i class="fas fa-forward"></i> Next Level
                        </button>
                        <button class="overlay-btn" id="restartWinBtn">
                            <i class="fas fa-redo"></i> Play Again
                        </button>
                        <button class="overlay-btn" id="exitWinBtn">
                            <i class="fas fa-times"></i> Exit
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="game-sidebar">
            <h3><i class="fas fa-info-circle"></i> Game Info</h3>
            <div class="info-card">
                <h4>Controls</h4>
                <div class="control-list">
                    <div class="control-item">
                        <kbd>‚Üê ‚Üí</kbd>
                        <span>Move Left/Right</span>
                    </div>
                    <div class="control-item">
                        <kbd>‚Üë / W / Space</kbd>
                        <span>Jump</span>
                    </div>
                    <div class="control-item">
                        <kbd>R</kbd>
                        <span>Restart Level</span>
                    </div>
                    <div class="control-item">
                        <kbd>P / ESC</kbd>
                        <span>Pause Game</span>
                    </div>
                </div>
            </div>
            
            <div class="info-card">
                <h4>Objectives</h4>
                <ul class="objectives-list" id="objectivesList">
                    <li><i class="fas fa-flag"></i> Reach the finish flag</li>
                    <li><i class="fas fa-coins"></i> Collect coins for bonus points</li>
                    <li><i class="fas fa-heart"></i> Avoid obstacles and enemies</li>
                </ul>
            </div>
            
            <div class="info-card">
                <h4>Live Players</h4>
                <div class="players-list" id="playersList">
                    <!-- Other players will appear here in multiplayer -->
                    <div class="player-item">
                        <div class="player-avatar">
                            <i class="fas fa-user"></i>
                        </div>
                        <div class="player-info">
                            <span class="player-name">You</span>
                            <span class="player-status online">Playing</span>
                        </div>
                        <div class="player-score">0</div>
                    </div>
                </div>
            </div>
            
            <div class="info-card">
                <h4>Leaderboard</h4>
                <div class="leaderboard" id="leaderboard">
                    <div class="leaderboard-item">
                        <span class="rank">1</span>
                        <span class="name">Player1</span>
                        <span class="score">1000</span>
                    </div>
                    <!-- More entries will be loaded -->
                </div>
            </div>
        </div>
    </div>
</div>

<style>
    .game-play-container {
        height: calc(100vh - 100px);
        display: flex;
        flex-direction: column;
        background: #1a1a2e;
        border-radius: 10px;
        overflow: hidden;
    }
    
    .game-header {
        background: #252547;
        padding: 15px 20px;
        border-bottom: 2px solid #00adb5;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 15px;
    }
    
    .game-info h2 {
        color: white;
        font-size: 1.5em;
        margin-bottom: 5px;
    }
    
    .game-meta {
        display: flex;
        gap: 15px;
        color: #8a8da0;
        font-size: 0.9em;
    }
    
    .game-stats {
        display: flex;
        gap: 20px;
    }
    
    .stat-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 1.2em;
        color: white;
        background: rgba(255,255,255,0.1);
        padding: 8px 15px;
        border-radius: 20px;
    }
    
    .stat-item i {
        color: #00adb5;
    }
    
    .game-controls-top {
        display: flex;
        gap: 10px;
    }
    
    .game-btn {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #3a3a6a;
        border: none;
        color: white;
        font-size: 16px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s;
    }
    
    .game-btn:hover {
        background: #00adb5;
        transform: scale(1.1);
    }
    
    .game-content {
        flex: 1;
        display: grid;
        grid-template-columns: 1fr 300px;
        gap: 15px;
        padding: 15px;
        overflow: hidden;
    }
    
    @media (max-width: 768px) {
        .game-content {
            grid-template-columns: 1fr;
            grid-template-rows: 1fr auto;
        }
        
        .game-sidebar {
            order: -1;
        }
    }
    
    .game-canvas-container {
        position: relative;
        background: #0f0f1f;
        border-radius: 10px;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    
    #gameCanvas {
        background: #1a1a2e;
        display: block;
        max-width: 100%;
        max-height: 100%;
        border-radius: 5px;
    }
    
    .mobile-controls {
        position: absolute;
        bottom: 20px;
        left: 0;
        right: 0;
        display: none;
        justify-content: space-between;
        padding: 0 20px;
        z-index: 100;
    }
    
    @media (max-width: 768px) {
        .mobile-controls {
            display: flex;
        }
    }
    
    .control-stick {
        width: 100px;
        height: 100px;
        background: rgba(0, 173, 181, 0.3);
        border-radius: 50%;
        position: relative;
        border: 2px solid rgba(255,255,255,0.5);
    }
    
    .stick-inner {
        width: 50px;
        height: 50px;
        background: rgba(255,255,255,0.8);
        border-radius: 50%;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }
    
    .control-buttons {
        display: flex;
        gap: 20px;
        align-items: center;
    }
    
    .control-btn {
        width: 70px;
        height: 70px;
        border-radius: 50%;
        background: rgba(231, 76, 60, 0.8);
        border: 2px solid rgba(255,255,255,0.5);
        color: white;
        font-size: 24px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .control-btn.jump {
        background: rgba(46, 204, 113, 0.8);
    }
    
    .game-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }
    
    .overlay-content {
        background: #252547;
        padding: 40px;
        border-radius: 15px;
        border: 3px solid #00adb5;
        max-width: 500px;
        width: 90%;
        text-align: center;
    }
    
    .overlay-content h2 {
        color: #00adb5;
        margin-bottom: 20px;
        font-size: 2em;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
    }
    
    .overlay-stats {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 20px;
        margin: 30px 0;
        padding: 20px;
        background: rgba(0,0,0,0.3);
        border-radius: 10px;
    }
    
    .overlay-stats div {
        color: white;
        font-size: 1.2em;
    }
    
    .overlay-stats span {
        color: #00adb5;
        font-weight: bold;
    }
    
    .overlay-buttons {
        display: flex;
        gap: 15px;
        justify-content: center;
        flex-wrap: wrap;
    }
    
    .overlay-btn {
        padding: 15px 25px;
        background: #3a3a6a;
        border: none;
        border-radius: 8px;
        color: white;
        font-size: 16px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
        transition: all 0.3s;
    }
    
    .overlay-btn:hover {
        background: #00adb5;
        transform: translateY(-2px);
    }
    
    .achievements {
        margin: 20px 0;
        padding: 20px;
        background: rgba(255, 215, 0, 0.1);
        border: 1px solid gold;
        border-radius: 10px;
    }
    
    .achievement-item {
        display: flex;
        align-items: center;
        gap: 10px;
        color: gold;
        margin-bottom: 10px;
        padding: 10px;
        background: rgba(255, 215, 0, 0.2);
        border-radius: 5px;
    }
    
    .game-sidebar {
        background: #252547;
        border-radius: 10px;
        padding: 20px;
        overflow-y: auto;
    }
    
    .game-sidebar h3 {
        color: #00adb5;
        margin-bottom: 20px;
        font-size: 1.3em;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .info-card {
        background: #1a1a2e;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
    }
    
    .info-card h4 {
        color: white;
        margin-bottom: 15px;
        font-size: 1.1em;
    }
    
    .control-list {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }
    
    .control-item {
        display: flex;
        align-items: center;
        gap: 15px;
        padding: 8px;
        background: rgba(255,255,255,0.05);
        border-radius: 5px;
    }
    
    .control-item kbd {
        background: #00adb5;
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-family: monospace;
        min-width: 60px;
        text-align: center;
    }
    
    .control-item span {
        color: #8a8da0;
        flex: 1;
    }
    
    .objectives-list {
        list-style: none;
        padding: 0;
    }
    
    .objectives-list li {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px 0;
        color: #8a8da0;
        border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    
    .objectives-list li i {
        color: #00adb5;
    }
    
    .players-list {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }
    
    .player-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px;
        background: rgba(255,255,255,0.05);
        border-radius: 5px;
    }
    
    .player-avatar {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #00adb5;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
    }
    
    .player-info {
        flex: 1;
        display: flex;
        flex-direction: column;
    }
    
    .player-name {
        color: white;
        font-weight: bold;
    }
    
    .player-status {
        font-size: 0.8em;
        color: #8a8da0;
    }
    
    .player-status.online {
        color: #27ae60;
    }
    
    .player-score {
        color: gold;
        font-weight: bold;
    }
    
    .leaderboard {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }
    
    .leaderboard-item {
        display: flex;
        align-items: center;
        padding: 10px;
        background: rgba(255,255,255,0.05);
        border-radius: 5px;
    }
    
    .leaderboard-item .rank {
        width: 30px;
        height: 30px;
        background: #00adb5;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: bold;
    }
    
    .leaderboard-item .name {
        flex: 1;
        margin: 0 15px;
        color: white;
    }
    
    .leaderboard-item .score {
        color: gold;
        font-weight: bold;
    }
</style>

<script>
    // Game Engine Runtime
    document.addEventListener('DOMContentLoaded', async function() {
        const gameState = {
            canvas: null,
            ctx: null,
            isRunning: false,
            isPaused: false,
            gameTime: 0,
            gameData: null,
            player: null,
            objects: [],
            camera: { x: 0, y: 0 },
            keys: {},
            touchControls: {},
            gameLoop: null,
            lastTime: 0,
            particles: [],
            coins: 0,
            score: 0,
            health: 100,
            isGameOver: false,
            isComplete: false
        };
        
        // Initialize game
        await initializeGame();
        
        // Setup event listeners
        setupGameEvents();
        
        // Start game loop
        startGame();
    });
    
    async function initializeGame() {
        // Get canvas and context
        gameState.canvas = document.getElementById('gameCanvas');
        gameState.ctx = gameState.canvas.getContext('2d');
        
        // Try to get game data from navigation parameters or load default
        const urlParams = new URLSearchParams(window.location.search);
        const gameId = urlParams.get('id');
        
        if (gameId) {
            // Load game from database
            await loadGameFromDatabase(gameId);
        } else {
            // Check if game data was passed from studio
            if (window.gameData) {
                gameState.gameData = window.gameData;
                setupGameFromData();
            } else {
                // Load default test level
                await loadDefaultLevel();
            }
        }
        
        // Initialize player
        initializePlayer();
        
        // Setup camera
        setupCamera();
        
        // Setup touch controls for mobile
        setupTouchControls();
    }
    
    async function loadGameFromDatabase(gameId) {
        try {
            const gameRef = window.firebaseDatabase.ref(`games/${gameId}`);
            const snapshot = await gameRef.once('value');
            
            if (snapshot.exists()) {
                gameState.gameData = snapshot.val();
                setupGameFromData();
                
                // Update game info display
                document.getElementById('gameTitle').textContent = gameState.gameData.name;
                document.getElementById('gameAuthor').textContent = `By: ${gameState.gameData.ownerName || 'Unknown'}`;
                document.getElementById('gameDifficulty').textContent = `Difficulty: ${gameState.gameData.settings?.difficulty || 'Medium'}`;
                
                // Increment play count
                await gameRef.update({
                    plays: firebase.database.ServerValue.increment(1)
                });
            } else {
                throw new Error('Game not found');
            }
        } catch (error) {
            console.error('Error loading game:', error);
            showToast('Failed to load game');
            await loadDefaultLevel();
        }
    }
    
    async function loadDefaultLevel() {
        // Create a default test level
        gameState.gameData = {
            name: 'Test Level',
            description: 'Default test level',
            settings: {
                gravity: 0.5,
                jumpForce: 12,
                backgroundColor: '#1a1a2e',
                timeLimit: 0,
                difficulty: 'medium'
            },
            objects: [
                { type: 'platform', x: 0, y: 400, width: 800, height: 50, color: '#2ecc71' },
                { type: 'platform', x: 100, y: 300, width: 100, height: 20, color: '#2ecc71' },
                { type: 'platform', x: 300, y: 250, width: 100, height: 20, color: '#2ecc71' },
                { type: 'platform', x: 500, y: 200, width: 100, height: 20, color: '#2ecc71' },
                { type: 'coin', x: 150, y: 250, width: 20, height: 20, value: 1 },
                { type: 'coin', x: 350, y: 200, width: 20, height: 20, value: 1 },
                { type: 'coin', x: 550, y: 150, width: 20, height: 20, value: 1 },
                { type: 'spike', x: 250, y: 380, width: 30, height: 20, damage: 10 },
                { type: 'flag', x: 700, y: 150, width: 30, height: 100, color: '#e74c3c' },
                { type: 'player', x: 50, y: 350, width: 32, height: 64, color: '#3498db' }
            ]
        };
        
        setupGameFromData();
    }
    
    function setupGameFromData() {
        // Set game objects from data
        gameState.objects = gameState.gameData.objects || [];
        
        // Find player start position
        const playerObj = gameState.objects.find(obj => obj.type === 'player');
        if (playerObj) {
            gameState.playerStart = { x: playerObj.x, y: playerObj.y };
        } else {
            gameState.playerStart = { x: 100, y: 100 };
        }
        
        // Remove player object from objects list (it's not a physical object)
        gameState.objects = gameState.objects.filter(obj => obj.type !== 'player');
        
        // Update game info
        document.getElementById('gameTitle').textContent = gameState.gameData.name || 'Untitled Game';
        document.getElementById('gameAuthor').textContent = gameState.gameData.ownerName ? `By: ${gameState.gameData.ownerName}` : '';
        document.getElementById('gameDifficulty').textContent = `Difficulty: ${gameState.gameData.settings?.difficulty || 'Medium'}`;
        
        // Setup time limit if any
        if (gameState.gameData.settings?.timeLimit > 0) {
            gameState.timeLimit = gameState.gameData.settings.timeLimit;
        }
    }
    
    function initializePlayer() {
        gameState.player = {
            x: gameState.playerStart?.x || 100,
            y: gameState.playerStart?.y || 100,
            width: 32,
            height: 64,
            velocityX: 0,
            velocityY: 0,
            speed: 5,
            jumpForce: gameState.gameData?.settings?.jumpForce || 12,
            isOnGround: false,
            isJumping: false,
            facing: 'right',
            health: 100,
            coins: 0,
            score: 0,
            invincible: false,
            invincibleTimer: 0
        };
        
        // Update UI
        updateUI();
    }
    
    function setupCamera() {
        gameState.camera = {
            x: gameState.player.x - gameState.canvas.width / 2,
            y: gameState.player.y - gameState.canvas.height / 2,
            width: gameState.canvas.width,
            height: gameState.canvas.height,
            smoothness: 0.1
        };
    }
    
    function setupTouchControls() {
        const leftStick = document.getElementById('leftStick');
        const mobileJump = document.getElementById('mobileJump');
        const mobileAction = document.getElementById('mobileAction');
        
        if (leftStick) {
            let isTouching = false;
            let touchStartX = 0;
            let touchStartY = 0;
            
            leftStick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isTouching = true;
                const touch = e.touches[0];
                const rect = leftStick.getBoundingClientRect();
                touchStartX = touch.clientX - rect.left;
                touchStartY = touch.clientY - rect.top;
                updateStickPosition(touchStartX, touchStartY);
            });
            
            leftStick.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!isTouching) return;
                
                const touch = e.touches[0];
                const rect = leftStick.getBoundingClientRect();
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;
                
                updateStickPosition(touchX, touchY);
            });
            
            leftStick.addEventListener('touchend', (e) => {
                e.preventDefault();
                isTouching = false;
                resetStickPosition();
            });
            
            leftStick.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                isTouching = false;
                resetStickPosition();
            });
        }
        
        if (mobileJump) {
            mobileJump.addEventListener('touchstart', (e) => {
                e.preventDefault();
                gameState.keys[' '] = true;
            });
            
            mobileJump.addEventListener('touchend', (e) => {
                e.preventDefault();
                gameState.keys[' '] = false;
            });
        }
        
        if (mobileAction) {
            mobileAction.addEventListener('touchstart', (e) => {
                e.preventDefault();
                gameState.keys['Shift'] = true;
            });
            
            mobileAction.addEventListener('touchend', (e) => {
                e.preventDefault();
                gameState.keys['Shift'] = false;
            });
        }
    }
    
    function updateStickPosition(x, y) {
        const stick = leftStick.querySelector('.stick-inner');
        const rect = leftStick.getBoundingClientRect();
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        
        const deltaX = x - centerX;
        const deltaY = y - centerY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        const maxDistance = rect.width / 2 - 25;
        
        let moveX = deltaX;
        let moveY = deltaY;
        
        if (distance > maxDistance) {
            moveX = (deltaX / distance) * maxDistance;
            moveY = (deltaY / distance) * maxDistance;
        }
        
        // Update stick visual position
        stick.style.transform = `translate(${moveX}px, ${moveY}px)`;
        
        // Update game controls
        const deadzone = 10;
        if (Math.abs(moveX) > deadzone) {
            gameState.keys.ArrowLeft = moveX < -deadzone;
            gameState.keys.ArrowRight = moveX > deadzone;
        } else {
            gameState.keys.ArrowLeft = false;
            gameState.keys.ArrowRight = false;
        }
    }
    
    function resetStickPosition() {
        const stick = leftStick.querySelector('.stick-inner');
        stick.style.transform = 'translate(-50%, -50%)';
        gameState.keys.ArrowLeft = false;
        gameState.keys.ArrowRight = false;
    }
    
    function setupGameEvents() {
        // Keyboard controls
        window.addEventListener('keydown', (e) => {
            gameState.keys[e.key] = true;
            
            // Prevent arrow key scrolling
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
            
            // Pause game
            if (e.key === 'p' || e.key === 'Escape') {
                togglePause();
            }
            
            // Restart game
            if (e.key === 'r') {
                restartGame();
            }
        });
        
        window.addEventListener('keyup', (e) => {
            gameState.keys[e.key] = false;
        });
        
        // Game control buttons
        document.getElementById('pauseBtn').addEventListener('click', togglePause);
        document.getElementById('restartBtn').addEventListener('click', restartGame);
        document.getElementById('exitBtn').addEventListener('click', () => navigateTo('game'));
        
        // Overlay buttons
        document.getElementById('resumeBtn').addEventListener('click', togglePause);
        document.getElementById('restartOverlayBtn').addEventListener('click', restartGame);
        document.getElementById('exitOverlayBtn').addEventListener('click', () => navigateTo('game'));
        document.getElementById('retryBtn').addEventListener('click', restartGame);
        document.getElementById('exitGameOverBtn').addEventListener('click', () => navigateTo('game'));
        document.getElementById('restartWinBtn').addEventListener('click', restartGame);
        document.getElementById('exitWinBtn').addEventListener('click', () => navigateTo('game'));
        
        // Next level button (placeholder)
        document.getElementById('nextLevelBtn').addEventListener('click', () => {
            showToast('Next level feature coming soon!');
        });
        
        // Window resize
        window.addEventListener('resize', resizeCanvas);
    }
    
    function resizeCanvas() {
        // Adjust canvas size while maintaining aspect ratio
        const container = gameState.canvas.parentElement;
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;
        
        // Maintain 4:3 aspect ratio
        const aspectRatio = 4/3;
        let width = containerWidth;
        let height = containerHeight;
        
        if (width / height > aspectRatio) {
            width = height * aspectRatio;
        } else {
            height = width / aspectRatio;
        }
        
        gameState.canvas.width = width;
        gameState.canvas.height = height;
        gameState.camera.width = width;
        gameState.camera.height = height;
    }
    
    function startGame() {
        gameState.isRunning = true;
        gameState.lastTime = performance.now();
        gameState.gameLoop = requestAnimationFrame(updateGame);
        
        // Start game timer
        gameState.gameTime = 0;
        gameState.timerInterval = setInterval(() => {
            if (!gameState.isPaused && !gameState.isGameOver && !gameState.isComplete) {
                gameState.gameTime++;
                updateTimerDisplay();
                
                // Check time limit
                if (gameState.timeLimit && gameState.gameTime > gameState.timeLimit) {
                    gameOver('Time\'s up!');
                }
            }
        }, 1000);
    }
    
    function updateGame(currentTime) {
        if (!gameState.isRunning) return;
        
        const deltaTime = (currentTime - gameState.lastTime) / 16.67; // Normalize to ~60fps
        gameState.lastTime = currentTime;
        
        if (!gameState.isPaused && !gameState.isGameOver && !gameState.isComplete) {
            // Update game state
            updatePlayer(deltaTime);
            updateCamera();
            updateParticles(deltaTime);
            checkCollisions();
        }
        
        // Render everything
        render();
        
        // Continue game loop
        gameState.gameLoop = requestAnimationFrame(updateGame);
    }
    
    function updatePlayer(deltaTime) {
        const player = gameState.player;
        
        // Handle input
        let moveX = 0;
        if (gameState.keys.ArrowLeft || gameState.keys.a || gameState.keys.A) {
            moveX = -1;
            player.facing = 'left';
        }
        if (gameState.keys.ArrowRight || gameState.keys.d || gameState.keys.D) {
            moveX = 1;
            player.facing = 'right';
        }
        
        // Apply movement
        player.velocityX = moveX * player.speed;
        
        // Jump
        if ((gameState.keys[' '] || gameState.keys.ArrowUp || gameState.keys.w || gameState.keys.W) && player.isOnGround) {
            player.velocityY = -player.jumpForce;
            player.isOnGround = false;
            player.isJumping = true;
            
            // Create jump particles
            createParticles(player.x + player.width/2, player.y + player.height, 5, '#3498db');
        }
        
        // Apply gravity
        const gravity = gameState.gameData?.settings?.gravity || 0.5;
        player.velocityY += gravity;
        
        // Apply velocity
        player.x += player.velocityX;
        player.y += player.velocityY;
        
        // Apply friction
        if (player.isOnGround) {
            player.velocityX *= 0.8;
        }
        
        // Screen boundaries
        const worldWidth = 1600;
        const worldHeight = 1200;
        
        if (player.x < 0) player.x = 0;
        if (player.x + player.width > worldWidth) player.x = worldWidth - player.width;
        if (player.y < 0) player.y = 0;
        if (player.y + player.height > worldHeight) {
            player.y = worldHeight - player.height;
            player.isOnGround = true;
            player.velocityY = 0;
        }
        
        // Update invincibility timer
        if (player.invincible) {
            player.invincibleTimer -= deltaTime;
            if (player.invincibleTimer <= 0) {
                player.invincible = false;
            }
        }
    }
    
    function updateCamera() {
        const camera = gameState.camera;
        const player = gameState.player;
        
        // Smooth camera follow
        const targetX = player.x + player.width/2 - camera.width/2;
        const targetY = player.y + player.height/2 - camera.height/2;
        
        camera.x += (targetX - camera.x) * camera.smoothness;
        camera.y += (targetY - camera.y) * camera.smoothness;
        
        // Camera boundaries
        const worldWidth = 1600;
        const worldHeight = 1200;
        
        if (camera.x < 0) camera.x = 0;
        if (camera.x + camera.width > worldWidth) camera.x = worldWidth - camera.width;
        if (camera.y < 0) camera.y = 0;
        if (camera.y + camera.height > worldHeight) camera.y = worldHeight - camera.height;
    }
    
    function updateParticles(deltaTime) {
        for (let i = gameState.particles.length - 1; i >= 0; i--) {
            const particle = gameState.particles[i];
            
            particle.x += particle.vx;
            particle.y += particle.vy;
            particle.vy += particle.gravity;
            particle.life -= deltaTime;
            
            if (particle.life <= 0) {
                gameState.particles.splice(i, 1);
            }
        }
    }
    
    function checkCollisions() {
        const player = gameState.player;
        player.isOnGround = false;
        
        for (const obj of gameState.objects) {
            if (checkCollision(player, obj)) {
                handleCollision(player, obj);
            }
        }
    }
    
    function checkCollision(rect1, rect2) {
        return rect1.x < rect2.x + rect2.width &&
               rect1.x + rect1.width > rect2.x &&
               rect1.y < rect2.y + rect2.height &&
               rect1.y + rect1.height > rect2.y;
    }
    
    function handleCollision(player, obj) {
        switch(obj.type) {
            case 'platform':
                handlePlatformCollision(player, obj);
                break;
            case 'spike':
                handleSpikeCollision(player, obj);
                break;
            case 'coin':
                handleCoinCollision(player, obj);
                break;
            case 'flag':
                handleFlagCollision(player, obj);
                break;
            case 'enemy':
                handleEnemyCollision(player, obj);
                break;
        }
    }
    
    function handlePlatformCollision(player, platform) {
        // Simple platform collision from top
        const playerBottom = player.y + player.height;
        const platformTop = platform.y;
        
        if (playerBottom > platformTop && player.velocityY > 0) {
            player.y = platformTop - player.height;
            player.velocityY = 0;
            player.isOnGround = true;
            player.isJumping = false;
        }
    }
    
    function handleSpikeCollision(player, spike) {
        if (!player.invincible) {
            player.health -= spike.damage || 10;
            player.invincible = true;
            player.invincibleTimer = 60; // 1 second at 60fps
            
            // Create hit particles
            createParticles(player.x + player.width/2, player.y + player.height/2, 10, '#e74c3c');
            
            // Knockback
            player.velocityY = -8;
            
            updateUI();
            
            if (player.health <= 0) {
                gameOver('You died!');
            }
        }
    }
    
    function handleCoinCollision(player, coin) {
        // Remove coin
        const index = gameState.objects.indexOf(coin);
        if (index !== -1) {
            gameState.objects.splice(index, 1);
            
            // Add to player's coins
            player.coins += coin.value || 1;
            player.score += 100;
            
            // Create coin collection particles
            createParticles(coin.x + coin.width/2, coin.y + coin.height/2, 15, '#FFD700');
            
            updateUI();
            
            // Play sound (if implemented)
            playCoinSound();
        }
    }
    
    function handleFlagCollision(player, flag) {
        if (!gameState.isComplete) {
            completeLevel();
        }
    }
    
    function handleEnemyCollision(player, enemy) {
        if (!player.invincible) {
            player.health -= enemy.damage || 20;
            player.invincible = true;
            player.invincibleTimer = 60;
            
            // Knockback
            const knockbackDirection = player.x < enemy.x ? -1 : 1;
            player.velocityX = -5 * knockbackDirection;
            player.velocityY = -8;
            
            updateUI();
            
            if (player.health <= 0) {
                gameOver('You died!');
            }
        }
    }
    
    function createParticles(x, y, count, color) {
        for (let i = 0; i < count; i++) {
            gameState.particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                gravity: 0.1,
                size: Math.random() * 3 + 2,
                color: color,
                life: 30 + Math.random() * 30
            });
        }
    }
    
    function render() {
        const ctx = gameState.ctx;
        const camera = gameState.camera;
        
        // Clear canvas
        const bgColor = gameState.gameData?.settings?.backgroundColor || '#1a1a2e';
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, gameState.canvas.width, gameState.canvas.height);
        
        // Save context for camera translation
        ctx.save();
        ctx.translate(-camera.x, -camera.y);
        
        // Draw game objects
        gameState.objects.forEach(obj => {
            drawObject(ctx, obj);
        });
        
        // Draw player
        drawPlayer(ctx, gameState.player);
        
        // Draw particles
        gameState.particles.forEach(particle => {
            drawParticle(ctx, particle);
        });
        
        // Restore context
        ctx.restore();
        
        // Draw UI elements (not affected by camera)
        drawUI(ctx);
    }
    
    function drawObject(ctx, obj) {
        ctx.save();
        
        const x = obj.x;
        const y = obj.y;
        const width = obj.width;
        const height = obj.height;
        
        switch(obj.type) {
            case 'platform':
                // Platform with grass on top
                ctx.fillStyle = obj.color || '#2ecc71';
                ctx.fillRect(x, y, width, height);
                
                // Grass top
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(x, y, width, 4);
                
                // Platform shadow
                ctx.strokeStyle = '#1e8449';
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, width, height);
                break;
                
            case 'spike':
                ctx.fillStyle = obj.color || '#e74c3c';
                ctx.beginPath();
                ctx.moveTo(x + width/2, y);
                ctx.lineTo(x, y + height);
                ctx.lineTo(x + width, y + height);
                ctx.closePath();
                ctx.fill();
                break;
                
            case 'coin':
                // Gold coin with shine
                const gradient = ctx.createRadialGradient(
                    x + width/2, y + height/2, 0,
                    x + width/2, y + height/2, width/2
                );
                gradient.addColorStop(0, '#FFD700');
                gradient.addColorStop(0.7, '#FFA500');
                gradient.addColorStop(1, '#FF8C00');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x + width/2, y + height/2, width/2, 0, Math.PI * 2);
                ctx.fill();
                
                // Coin shine
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(x + width/2 - width/4, y + height/2 - height/4, width/6, 0, Math.PI * 2);
                ctx.fill();
                break;
                
            case 'flag':
                // Flag pole
                ctx.fillStyle = '#7f8c8d';
                ctx.fillRect(x, y, 4, height);
                
                // Flag
                ctx.fillStyle = obj.color || '#e74c3c';
                ctx.beginPath();
                ctx.moveTo(x + 4, y);
                ctx.lineTo(x + width, y + height/3);
                ctx.lineTo(x + 4, y + height/1.5);
                ctx.closePath();
                ctx.fill();
                break;
                
            case 'enemy':
                // Slime enemy
                ctx.fillStyle = obj.color || '#9b59b6';
                ctx.beginPath();
                ctx.ellipse(x + width/2, y + height/2, width/2, height/2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Eyes
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(x + width/3, y + height/3, width/8, 0, Math.PI * 2);
                ctx.arc(x + width - width/3, y + height/3, width/8, 0, Math.PI * 2);
                ctx.fill();
                
                // Pupils
                ctx.fillStyle = '#2c3e50';
                ctx.beginPath();
                ctx.arc(x + width/3, y + height/3, width/16, 0, Math.PI * 2);
                ctx.arc(x + width - width/3, y + height/3, width/16, 0, Math.PI * 2);
                ctx.fill();
                break;
                
            default:
                ctx.fillStyle = obj.color || '#95a5a6';
                ctx.fillRect(x, y, width, height);
                ctx.strokeStyle = '#7f8c8d';
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, width, height);
        }
        
        ctx.restore();
    }
    
    function drawPlayer(ctx, player) {
        ctx.save();
        
        // Apply invincibility blink
        if (player.invincible && Math.floor(player.invincibleTimer / 3) % 2 === 0) {
            ctx.globalAlpha = 0.5;
        }
        
        const x = player.x;
        const y = player.y;
        const width = player.width;
        const height = player.height;
        
        // Player body
        ctx.fillStyle = player.color || '#3498db';
        ctx.fillRect(x, y, width, height);
        
        // Player face
        ctx.fillStyle = 'white';
        ctx.fillRect(x + width/4, y + height/4, width/8, height/8);
        ctx.fillRect(x + width - width/4 - width/8, y + height/4, width/8, height/8);
        
        // Player smile
        ctx.beginPath();
        ctx.arc(x + width/2, y + height/2, width/4, 0, Math.PI);
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Walking animation
        if (player.velocityX !== 0 && player.isOnGround) {
            const footOffset = Math.sin(Date.now() / 100) * 5;
            ctx.fillStyle = '#2980b9';
            ctx.fillRect(x, y + height - 5, width/3, 5 + footOffset);
            ctx.fillRect(x + width - width/3, y + height - 5, width/3, 5 - footOffset);
        } else {
            ctx.fillStyle = '#2980b9';
            ctx.fillRect(x, y + height - 5, width, 5);
        }
        
        ctx.restore();
    }
    
    function drawParticle(ctx, particle) {
        ctx.save();
        
        ctx.globalAlpha = particle.life / 60;
        ctx.fillStyle = particle.color;
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }
    
    function drawUI(ctx) {
        // Health bar
        const healthBarWidth = 200;
        const healthBarHeight = 20;
        const healthBarX = 20;
        const healthBarY = 20;
        
        // Background
        ctx.fillStyle = '#333';
        ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
        
        // Health fill
        const healthPercent = gameState.player.health / 100;
        ctx.fillStyle = healthPercent > 0.5 ? '#2ecc71' : healthPercent > 0.25 ? '#f39c12' : '#e74c3c';
        ctx.fillRect(healthBarX, healthBarY, healthBarWidth * healthPercent, healthBarHeight);
        
        // Health border
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
        
        // Health text
        ctx.fillStyle = '#fff';
        ctx.font = '14px Arial';
        ctx.fillText(`HP: ${Math.max(0, Math.floor(gameState.player.health))}`, healthBarX + 5, healthBarY + 15);
        
        // Coin counter
        const coinX = healthBarX + healthBarWidth + 30;
        ctx.fillStyle = 'gold';
        ctx.font = 'bold 20px Arial';
        ctx.fillText('üí∞', coinX, healthBarY + 18);
        ctx.fillStyle = '#fff';
        ctx.fillText(`√ó ${gameState.player.coins}`, coinX + 25, healthBarY + 18);
        
        // Score
        const scoreX = coinX + 100;
        ctx.fillStyle = '#00adb5';
        ctx.font = 'bold 20px Arial';
        ctx.fillText('‚≠ê', scoreX, healthBarY + 18);
        ctx.fillStyle = '#fff';
        ctx.fillText(gameState.player.score, scoreX + 25, healthBarY + 18);
    }
    
    function updateUI() {
        document.getElementById('health').textContent = Math.max(0, Math.floor(gameState.player.health));
        document.getElementById('coins').textContent = gameState.player.coins;
        document.getElementById('score').textContent = gameState.player.score;
        
        // Update pause/win/game over screens
        document.getElementById('pauseCoins').textContent = gameState.player.coins;
        document.getElementById('pauseScore').textContent = gameState.player.score;
        
        document.getElementById('finalCoins').textContent = gameState.player.coins;
        document.getElementById('finalScore').textContent = gameState.player.score;
        
        document.getElementById('winCoins').textContent = gameState.player.coins;
        document.getElementById('winScore').textContent = gameState.player.score;
    }
    
    function updateTimerDisplay() {
        const minutes = Math.floor(gameState.gameTime / 60);
        const seconds = gameState.gameTime % 60;
        const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        
        document.getElementById('timer').textContent = timeString;
        document.getElementById('pauseTime').textContent = timeString;
        document.getElementById('finalTime').textContent = timeString;
        document.getElementById('winTime').textContent = timeString;
    }
    
    function togglePause() {
        gameState.isPaused = !gameState.isPaused;
        
        if (gameState.isPaused) {
            document.getElementById('pauseScreen').style.display = 'flex';
        } else {
            document.getElementById('pauseScreen').style.display = 'none';
        }
    }
    
    function restartGame() {
        // Reset game state
        gameState.isGameOver = false;
        gameState.isComplete = false;
        gameState.gameTime = 0;
        
        // Hide all overlays
        document.getElementById('pauseScreen').style.display = 'none';
        document.getElementById('gameOverScreen').style.display = 'none';
        document.getElementById('winScreen').style.display = 'none';
        
        // Reset player
        initializePlayer();
        
        // Reset objects (reload from game data)
        setupGameFromData();
        
        // Reset camera
        setupCamera();
        
        // Clear particles
        gameState.particles = [];
        
        // Update UI
        updateUI();
        updateTimerDisplay();
        
        // Resume if paused
        gameState.isPaused = false;
    }
    
    function gameOver(reason) {
        gameState.isGameOver = true;
        
        // Show game over screen
        document.getElementById('gameOverScreen').style.display = 'flex';
        
        // Save score to database if user is logged in
        saveGameResult('gameover');
        
        showToast(reason);
    }
    
    function completeLevel() {
        gameState.isComplete = true;
        
        // Calculate final score with time bonus
        const timeBonus = Math.max(0, 1000 - gameState.gameTime * 10);
        const coinBonus = gameState.player.coins * 50;
        gameState.player.score += timeBonus + coinBonus;
        
        // Show win screen
        document.getElementById('winScreen').style.display = 'flex';
        updateUI();
        
        // Generate achievements
        generateAchievements();
        
        // Save score to database
        saveGameResult('complete');
        
        // Reward player with coins
        if (window.currentUser()) {
            rewardPlayer();
        }
    }
    
    function generateAchievements() {
        const achievements = [];
        
        if (gameState.player.coins >= 10) {
            achievements.push({
                name: 'Coin Collector',
                description: 'Collected 10+ coins',
                icon: 'fas fa-coins',
                reward: 50
            });
        }
        
        if (gameState.player.health === 100) {
            achievements.push({
                name: 'Perfect Run',
                description: 'Completed level without taking damage',
                icon: 'fas fa-shield-alt',
                reward: 100
            });
        }
        
        if (gameState.gameTime < 60) {
            achievements.push({
                name: 'Speed Runner',
                description: 'Completed level in under 1 minute',
                icon: 'fas fa-running',
                reward: 75
            });
        }
        
        const achievementsContainer = document.getElementById('winAchievements');
        achievementsContainer.innerHTML = '';
        
        if (achievements.length > 0) {
            achievementsContainer.innerHTML = '<h3>Achievements Unlocked!</h3>';
            achievements.forEach(achievement => {
                const item = document.createElement('div');
                item.className = 'achievement-item';
                item.innerHTML = `
                    <i class="${achievement.icon}"></i>
                    <div>
                        <strong>${achievement.name}</strong>
                        <div>${achievement.description}</div>
                        <small>+${achievement.reward} coins</small>
                    </div>
                `;
                achievementsContainer.appendChild(item);
            });
        }
    }
    
    async function saveGameResult(result) {
        if (!window.currentUser() || !gameState.gameData) return;
        
        try {
            const user = window.currentUser();
            const gameRef = window.firebaseDatabase.ref(`gameResults/${user.uid}`).push();
            
            await gameRef.set({
                gameId: gameState.gameData.id || 'test',
                gameName: gameState.gameData.name,
                result: result,
                score: gameState.player.score,
                coins: gameState.player.coins,
                time: gameState.gameTime,
                health: gameState.player.health,
                timestamp: Date.now()
            });
            
            // Update leaderboard if game has ID
            if (gameState.gameData.id) {
                const leaderboardRef = window.firebaseDatabase.ref(`leaderboards/${gameState.gameData.id}`);
                await leaderboardRef.push().set({
                    userId: user.uid,
                    username: user.displayName,
                    score: gameState.player.score,
                    time: gameState.gameTime,
                    timestamp: Date.now()
                });
            }
            
        } catch (error) {
            console.error('Error saving game result:', error);
        }
    }
    
    async function rewardPlayer() {
        if (!window.currentUser()) return;
        
        try {
            const user = window.currentUser();
            const userRef = window.firebaseDatabase.ref(`users/${user.uid}`);
            
            // Calculate reward
            const baseReward = 100;
            const coinReward = gameState.player.coins * 10;
            const timeBonus = Math.max(0, 500 - gameState.gameTime);
            const totalReward = baseReward + coinReward + timeBonus;
            
            await userRef.update({
                coins: firebase.database.ServerValue.increment(totalReward),
                gamesPlayed: firebase.database.ServerValue.increment(1),
                totalScore: firebase.database.ServerValue.increment(gameState.player.score)
            });
            
            showToast(`+${totalReward} coins earned!`);
            
        } catch (error) {
            console.error('Error rewarding player:', error);
        }
    }
    
    function playCoinSound() {
        // Create a simple coin sound using Web Audio API
        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 800;
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        } catch (error) {
            // Audio not supported or permission not granted
        }
    }
    
    // Initialize on load
    resizeCanvas();
</script>
